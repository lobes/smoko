welcome back everyone to another episode
of the Doom remake series and in this
video we are going to get started with
loading wad files so I'm going to open
up two new files in our project
directory one is w.h and the other is w.
C and in here we are going to add of
course the mandatory include guard and
after that let's create a struct called
Wad and this will represent all of the
data related to a wad file and uh we'll
currently leave this struct empty but we
will have a function that will return an
INT depending on the error status and it
will be called V load from file it will
of course take the actual file name
along with the pointer to the v in which
to load this and I'm going to copy this
from here go under V.C in here let's
just include the v. H and create an
implementation of this function uh if
everything succeeds we are going to
return zero at the end uh much like how
you know standard uh error codes work
and we are going to include stdi each
here so that we can access the file
system so we are going to open up uh the
file name and we are going to open it up
in read binary mode and if it's null
which means it failed to open up then we
are going to return with an error code
of one in the end we are just going to
close this file and it might also be
useful to make sure that the what
pointers that we actually get we are
supposed to write to it's not null uh
yeah we are going to if it's null we are
going to return with an error code and
we going to return with a different
error code in the file phase to open now
we load our whole file into a buffer by
getting the by you know moving to the
end of the file getting the size and
then loading it into a buffer of
appropriate size and the reason we do
that is because first of all it will
allow us easier Random Access we could
like access any point in the buffer that
we want without having to use FSE or
anything and secondly it would make it
much easier to uh you know deal with
different bite encoding so you know uh
the v files are always L andian but the
processor might be big andian in which
case it can cause some problems so we
just load it into a buffer like this and
in the end we free that buffer because
all of the data we need is going to be
uh stored in appropriate structures and
between these lines we are supposed to
read the actual data so we first need to
read the header of the B file it
consists of 12 bites the first four are
the FK characters IOD or P VOD and then
we have got the number of lumps in the
VOD or and we have also got a table
offset containing the location of the
directory now these last two Fields
we'll talk about them in more detail in
a second as far as the first field is
concerned that's just the type of the
vard if it's an IB it means it's a
complete game or if it's a p it means it
is just a patch W okay so to give
ourselves a bit more freedom we are
going to use a corrector pointer for the
actual ID instead of of having a
hardcoded array and for reading the
header we are first of all going to make
sure that the size of the file is not
less than 12 which is the actual header
size if it less than 12 we going to
return with error code of three which
means a malformed v file and we're going
to look at five bytes for our uh V's ID
because well four bytes are for the
actual ID and then the null Terminator
and then we'll use M Copy to copy uh the
first four bytes of this buffer into the
uh you know V ID here and then we're
going to set the last bite to zero
because because it's going to be the
null Terminator and it seems to give an
error because it seems like it included
the C++ version so let's see if it now
includes the correct one no it seems to
be including the C++ version let's just
change it to string.h and yeah that
should work now since we are managing
memory ourselves we are going to create
a V free function to prevent any memory
leak so we will create a V free function
which will take a v pointer and it will
free all of the data from it so in here
we'll create an implementation of that
and uh currently of course we are only
allocating memory for the ID so we'll
just free it and later on as we add more
stuff we're going to add the freeing
code for that as well to ensure proper
cleanup so to test the code we have
written I'm going to open up main. C and
in here I have already got the Doom 1. f
file here so we're going to create a w
here which we're going to just load from
with the Doom onew file and uh I'm using
the Shar version you can use the full
version if you want to and here we'll
just print the error code we'll print an
error like if it fails and then we'll
exit our program uh if the v file does
not load and if it does load then we are
going to print a small message just
telling the type of the v file you know
the actual ID variable and if I run this
right now you can see that it says that
loaded a VOD file of type iwad which is
indeed what our uh VOD file is now we
are going to go under w.h and we are
going to create to un sign integers here
and do note that the original Doom
source code has it as signed integers
but it makes more sense to use unsign
and their Valu is never negative anyway
so we can read them safely as unsign
integers as well so we are going to
create the numb Lums and directory
offset Fields inside of our w.h and in
order to read this from the buffer we
will Define a macro which will allow
reading a 4 byte inteior from any buffer
basically and this macro will like take
two arguments a the buffer actually
which we are reading from and an offset
so now we'll just uh read the buffer uh
stuff quite easily and we'll read it in
little endian order so for each bite we
read first of all the lowest significant
bite then the other one we're going to
shift it left by uh you know 8 Bits And
then the next one we're going to do it
similarly so basically uh you know it's
going to be pretty uh easy to understand
we are just uh uh you know doing a bunch
of cool bitwise operations and getting
our file that way and uh one problem so
is that I forgot to actually change the
offset so the first White is going to be
at offset plus one uh offset plus zero
which means just offset then plus one +
2 and + 3 now in order to read this uh
we are going to just say w and uh you
can see we have got like our numb Lums
here and we can just start it to read
i32 the buffer is going to be the same
but for the offset I'm going to save
four here and now we are going to read
the directory offset which will be of
course in our buffer but the offset will
be now it so let's go under main. C and
let's try to print this information as
well so we'll sa with this amount of
lumps and we'll use you here actually
because it's unsigned and then we'll say
with directory at whatever the directory
of that is we'll specify these values
here so in order to test this out I'm
going to go ahead and run this and what
you should see is that it says loaded a
file of type IOD with 1264 Lums and
directory at whatever this is and if you
were to actually test this out this is
indeed the correct data so yeah that's
that's pretty cool so now we are going
to read the directory which consistes
information about all of the different
lumps so this is the basic structure of
the directory and now we are going to
get started with reading this okay so in
order to do that I'm going to go here
and we're going to create a new struct
here for representing each lump in the
directory and now let's go ahead and add
a couple of different variables in there
first of all one for offset and one for
size and I'm also going to create a
character pointer here for the actual
name of the lump now in here we'll just
have an array of lumps uh pointer
because well uh you know dynamic arrays
we don't know the size at compile time
and we'll go over each of those lumps
and uh in here first of all we'll
calculate the offset of this current
directory which you can calculate quite
easily by getting the total offset of
the directory multiplied by I plus I
multili by 6 which is the size of each
directory we'll allocate appropriate
memory for our lumps and with that done
now we can go down here and get started
with actually reading this all right so
with that offset calculated we are going
to read this like this so we're going to
first of all read the offset of the
actual lump which is at the which is the
first entry as a 32-bit integer and then
the size which is red for the next four
bytes with as also as a 32-bit integer
and for the name it can be maximum uh 8
bytes and it may not be null terminated
so we are going to um allocate n right
of memory for the name and then we are
going to copy that appropriately so we
going to copy the buffer and of course
we are going to use offset Plus 8 as
actual you know where we want to read
from and we are going to copy eight
bytes from there and if it's less than
eight it will be null terminated and now
we are going to just set our name's last
value to be zero as the actual n
Terminator in case it's not there and uh
then uh inside of the main file we are
going to just print all of the lumps
here to test stuff out so I'm going to
just go ahead and print that those first
of all the name of the lump followed by
the actual you know data of the lump you
know the the size and the offset so we
are going to put the offset here and the
size as well and then if I go ahead and
run this what you should see is that uh
well we got a lot of stuff here and
actually that's a bit of a mistake I
forgot to put a new line after this so
we're going to put a new line and then
we're going to run again and now you can
see that we get all of our lumps here
and if you were to open it up and in an
editor like Slade you will find out that
we are getting all of the lump read
correctly which means that this is
basically working and now we can uh get
started with the actually you know uh
reading the lump data so for that we are
going to create a uh unsign easier
buffer here similar to the one we have
got here for actually storing the lumps
data and for that we are going to
allocate uh some bites for it and the
size of that is going to be equal to the
size of this lump so we just going to
say what lumps I do size and then we're
going to use M Copy to actually copy you
know into this data our uh buffer size
but we are going to use the lump offset
for the actual position and for the size
we'll just use the lump size and that
should copy all of the data here
correctly and that is going to be all we
need to test this and if I run this we
get no segmentation fults which means
that this code is working anyways guys
this is pretty much it for this video
and I'll see you in the next one in
which we'll get started with actually
taking some of this lump data and
loading it into some appropriate
structur so that we can visualize our
map first in 2D and before and after
that we'll move on to a 3D
representation so yeah guys stay tuned
for that make sure to like And subscribe
as well and share this video with other
people and I'll see you in the next one
and bye
